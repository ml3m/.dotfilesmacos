#!/bin/bash

# Colors array
colors=(
  '\033[31m' # Red
  '\033[32m' # Green
  '\033[33m' # Yellow
  '\033[34m' # Blue
  '\033[35m' # Purple
  '\033[36m' # Cyan
  '\033[91m' # Light Red
  '\033[92m' # Light Green
  '\033[93m' # Light Yellow
  '\033[94m' # Light Blue
  '\033[95m' # Light Purple
  '\033[96m' # Light Cyan
)
NC='\033[0m' # No Color
WHITE='\033[97m' # White

# Padding settings
LEFT_PADDING=4 # Number of spaces for left padding
TOP_PADDING=2 # Number of empty lines for top padding
BOTTOM_PADDING=2 # Number of empty lines for bottom padding
delay=${1:-0.30}

# Get System Information
get_os() {
  sw_vers -productName
}

get_os_version() {
  sw_vers -productVersion
}

get_hostname() {
  hostname
}

get_user() {
  whoami
}

get_packages() {
  formulas=$(brew list --formula | wc -l)
  echo "$formulas formulas"
}

get_uptime() {
  # Get uptime in seconds for macOS.
  boot=$(sysctl -n kern.boottime)
  boot=${boot/\{ sec = }
  boot=${boot/,*}

  # Get current date in seconds.
  now=$(date +%s)
  s=$((now - boot))

  d="$((s / 60 / 60 / 24)) days"
  h="$((s / 60 / 60 % 24)) hours"
  m="$((s / 60 % 60)) minutes"

  # Remove plural if < 2.
  (( ${d/ *} == 1 )) && d=${d/s}
  (( ${h/ *} == 1 )) && h=${h/s}
  (( ${m/ *} == 1 )) && m=${m/s}

  # Hide empty fields.
  (( ${d/ *} == 0 )) && unset d
  (( ${h/ *} == 0 )) && unset h
  (( ${m/ *} == 0 )) && unset m

  uptime="${d:+$d, }${h:+$h, }$m"
  uptime=${uptime%', '}
  uptime=${uptime:-"$s seconds"}

  # Make the output of uptime smaller.
  case $uptime_shorthand in
    on)
      uptime=${uptime/ minutes/ mins}
      uptime=${uptime/ minute/ min}
      uptime=${uptime/ seconds/ secs}
      ;;

    tiny)
      uptime=${uptime/ days/d}
      uptime=${uptime/ day/d}
      uptime=${uptime/ hours/h}
      uptime=${uptime/ hour/h}
      uptime=${uptime/ minutes/m}
      uptime=${uptime/ minute/m}
      uptime=${uptime/ seconds/s}
      uptime=${uptime//,}
      ;;
  esac

  echo "$uptime"
}

get_shell() {
  if [[ "$SHELL" == "/bin/zsh" ]]; then
    echo "zsh"
  else
    echo "$SHELL"
  fi
}

get_terminal() {
  # Prioritize iTerm2
  if [[ -n "$ITERM_SESSION_ID" ]]; then
    echo "iTerm2"
    return
  fi

  # Check for Ghostty
  if [[ -n "$GHOSTTY_VERSION" ]]; then
    echo "Ghostty"
    return
  fi

  # Check if running inside tmux
  if [[ -n "$TMUX" ]]; then
    # If inside tmux, try to get the underlying terminal from $TERM_PROGRAM
    if [[ -n "$TERM_PROGRAM" ]]; then
      echo "$TERM_PROGRAM"
      return
    fi
    # If $TERM_PROGRAM is not set, fallback to $TERM (might still be tmux)
    if [[ -n "$TERM" ]]; then
      echo "$TERM"
      return
    fi
  fi

  # Check for common terminal emulators (outside tmux)
  if [[ -n "$VTE_VERSION" ]]; then
    echo "GNOME Terminal"
    return
  fi

  if [[ -n "$KONSOLE_VERSION" ]]; then
    echo "Konsole"
    return
  fi

  # Check for VS Code integrated terminal
  if [[ -n "$VSCODE_PID" ]]; then
    echo "VS Code"
    return
  fi

  # Check for Hyper.js
  if [[ -n "$TERM_PROGRAM" && "$TERM_PROGRAM" == "Hyper" ]]; then
    echo "Hyper"
    return
  fi

  # If TERM is screen-256color, try to infer from $TERM_PROGRAM
  if [[ "$TERM" == "screen-256color" ]]; then
    if [[ -n "$TERM_PROGRAM" ]]; then
      echo "$TERM_PROGRAM"
      return
    fi
  fi

  # Fallback to $TERM (if it's not screen-256color or already handled)
  if [[ -n "$TERM" ]]; then
    echo "$TERM"
    return
  fi

  # Last resort: use tty
  tty | sed 's/\/dev\///'
}

get_cpu() {
  sysctl -n machdep.cpu.brand_string
}

get_memory() {
  total_mem=$(sysctl -n hw.memsize)
  total_mem_gb=$((total_mem / 1024 / 1024 / 1024))
  echo "${total_mem_gb}GB"
}

get_disk() {
  df -h / | awk 'NR==2 {print $2}' | sed 's/GiB/GB/g'
}

# Function to colorize a string randomly
# Function to colorize a string randomly
colorize_string() {
    local string="$1"
    local result=""
    local -i len=${#string}
    local skip_next=0
    
    for ((i = 0; i < len; i++)); do
        # Skip this iteration if we're in the middle of an escape sequence
        if ((skip_next > 0)); then
            skip_next=$((skip_next - 1))
            continue
        fi
        
        local char="${string:$i:1}"
        
        # Handle backslash escapes
        if [[ "$char" == "\\" ]]; then
            # Peek at next character
            if ((i + 1 < len)); then
                next_char="${string:$i+1:1}"
                # Keep backslash and next character together
                result+="${colors[$((RANDOM % ${#colors[@]}))]}\\${next_char}${NC}"
                skip_next=1
                continue
            fi
        fi
        
        # Handle single quotes
        if [[ "$char" == "'" ]]; then
            # Peek at surrounding characters for escape sequence
            if ((i > 0)) && [[ "${string:$i-1:1}" == "\\" ]]; then
                continue  # Skip this quote as it's part of an escape sequence
            fi
        fi
        
        # Regular character coloring
        if [[ "$char" != " " ]]; then
            result+="${colors[$((RANDOM % ${#colors[@]}))]}${char}${NC}"
        else
            result+="$char"
        fi
    done
    
    echo -e "$result"
}

# Function to get the visual length of a string (excluding color codes)
get_visual_length() {
  local string="$1"
  echo -n "$string" | sed 's/\x1b\[[0-9;]*m//g' | wc -c
}

# Function to print empty lines
print_empty_lines() {
  local count=$1
  for ((i = 0; i < count; i++)); do
    echo
  done
}

# Prepare system information with different colors for each row
hostname_text="$(get_user)@$(get_hostname)"
hostname_line="${WHITE}${hostname_text}${NC}"

# Calculate separator length based on the text content of the first line
separator_length=${#hostname_text}
separator=$(printf "%${separator_length}s" | tr " " "-")

sys_info=(
  "$hostname_line" # Added Host/Name in white
  "${colors[8]}${separator}${NC}"
  "${colors[0]}OS: $(get_os) $(get_os_version)${NC}"
  "${colors[1]}Uptime: $(get_uptime)${NC}"
  "${colors[2]}Shell: $(get_shell)${NC}"
  "${colors[3]}Terminal: $(get_terminal)${NC}"
  #"${colors[7]}Packages: $(get_packages)${NC}"
  "${colors[4]}CPU: $(get_cpu)${NC}"
  "${colors[5]}Memory: $(get_memory)${NC}"
  "${colors[6]}Disk: $(get_disk)${NC}"
)


# used for allignment and spaces assist
#       _
#       \`*-.
#        )  _`-.
#       .  : `. .
#       : _   '  \
#       ; *` _.   `*-._
#       `-.-'          `-.
#         ;       `       `.
#         :.       .        \
#         . \  .   :   .-'   .
#         '  `+.;  ;  '      :
#         :  '  |  ,  ;       ;-.
#         ; '   : :`-:     _.`* ; 
#[bug] .*' /  .*' ; .*`- +'  `*'
#      `*-*   `*-*  `*-*'



# Animation frames array
# Frame 0 (air in)
# fixed formating
frame_0=(
'                               '
'                               '
'       _'
'       \`*-.'
'        )  _`-.'
'       .  : `. .'
'       : _   '\''  \\'
'       ; *` _.   `*-._'
'       `-.-'\''          `-.   '
'         ;       `       `.    '
'         :.       .        \\'
'         . \\  .   :   .-'\''   .'
'         '\''  `+.;  ;  '\''      :'
'         :  '\''  |  ,  ;       ;-.'
'         ; '\''   : :`-:     _.`*  ;'
'[bug] .*'\'' /  .*'\'' ; .*`- +'\''  `*'\''*'
'      `*-*   `*-*  `*-*'\''       '
)


# Frame 1 (air out)
# fixed formating
frame_1=(
'                               '
'                               '
''
'       _                        '
'       \`*-.                    '
'        )  _`-.                 '
'       .  : `. .                '
'       : _   '\''  \\               '
'       / *` _.   `*-._          '
'       `-.-'\''          `-.       '
'         :.              \\    '
'         . \\      `   .-. .   '
'         '\''  ._ ;  ;  '\''     :   '
'         :  , `|  ,  ;      ;-.'
'         ; '\''   : :`-:    _.`*  ;'
'[bug] .*'\'' /  .*'\'' ; .*`- +'\''  `*'\'' '
'      `*-*   `*-*  `*-*'\''       '
)

# Frame 2 (paw)
frame_2=(
'                               '
'                               '
''
'        _                        '
'        \`*,.                   '
'        /  _ `-.                 '
'       .  : `, `.                '
'       ; _   '\''  |               '
'       / *` _,   `*-._          '
'       `-`'\''           `-.       '
'         : .             \\    '
'         ; ;      `   .-. .   '
'        , ; `. ;  ;  '\''     :   '
'    .*'\''` /    `|  ,  ;      ;-.'
'    `*-'\''`      ; :`-:    _.`*  ;'
'[bug]        .*'\'' ; .*`- +`  `*'\'' '
'             `*-*  `*-*'\''       '
)

# Frame 3 (bug to mouth 1)
frame_3=(
'                               '
'                               '
''
'        _                        '
'        \`*,.                   '
'        /  _ `-.                 '
'       .  : `, `.                '
'       ; _   '\''  |               '
'       / *` _,   `*-._          '
'       `-`'\''           `-.       '
'         : .             \\    '
'         ; ;      `   .-. .   '
' [bug]  , ; `. ;  ;  '\''     :   '
'    .*'\''` /    `|  ,  ;      ;-.'
'    `*-'\''`      ; :`-:    _.`*  ;'
'             .*'\'' ; .*`- +`  `*'\'' '
'             `*-*  `*-*'\''       '
)

# Frame 4 (bug to mouth 2)
frame_4=(
'                               '
'                               '
''
'        _                        '
'        \`*,.                   '
'        /  _ `-.                 '
'       .  : `, `.                '
'       ; _   '\''  |               '
'       / *` _,   `*-._          '
'       `-`'\''           `-.       '
'         : .             \\    '
'   [bug], ,;      `   .-. .   '
'    ,-'\''` /  `. ;  ;  '\''     :   '
'    `*-'\''`     `|  ,  ;      ;-.'
'               ; :`-:    _.`*  ;'
'             .*'\'' ; .*`- +`  `*'\'' '
'             `*-*  `*-*'\''       '
)

# Frame 5 (bug to mouth 3)
frame_5=(
'                               '
'                               '
''
'        _                        '
'        \`*,.                   '
'        /  _ `-.                 '
'       .  : `, `.                '
'       ; _   '\''  |               '
'       / *` _,   `*-._          '
'       `-`'\''           `-.       '
'    [bug]: ,             \\    '
'    ;`'\''` /,;      `   .-. .   '
'    `*-'\''`   `. ;  ;  '\''     :   '
'              `|  ,  ;      ;-.'
'               ; :`-:    _.`*  ;'
'             .*'\'' ; .*`- +`  `*'\'' '
'             `*-*  `*-*'\''       '
)

# Frame 6 (back to paw)
frame_6=(
'                               '
'                               '
''
'        _                        '
'        \`*,.                   '
'        /  _ `-.                 '
'       .  : `, `.                '
'       ; _   '\''  |               '
'       / *` _,   `*-._          '
'       `-`'\''           `-.       '
'         : .             \\    '
'         ; ;      `   .-. .   '
'        , ; `. ;  ;  '\''     :   '
'    .*'\''` /    `|  ,  ;      ;-.'
'    `*-'\''`      ; :`-:    _.`*  ;'
'             .*'\'' ; .*`- +`  `*'\'' '
'             `*-*  `*-*'\''       '
)

# Array of frame variable names
frames=(frame_0 frame_1 frame_2 frame_3 frame_4 frame_5 frame_6)
# Function to move cursor up N lines
move_cursor_up() {
    local lines=$1
    tput cuu $lines
}

# Function to save cursor position
save_cursor_position() {
    tput sc
}

# Function to restore cursor position
restore_cursor_position() {
    tput rc
}

# Function to continuously update colors and animate frames
update_colors() {
    local frame_count=${#frames[@]}
    local current_frame=0
    
    # Safety check to avoid division by zero
    if [ "$frame_count" -eq 0 ]; then
        echo "Error: No frames available for animation"
        return 1
    fi
    
    while true; do
        # Save current cursor position
        save_cursor_position
        
        # Build the entire frame as a single string
        local frame_output=""
        local frame_name="${frames[$current_frame]}"
        eval "current_frame_array=(\"\${${frame_name}[@]}\")"
        
        for i in "${!current_frame_array[@]}"; do
            # Create colored version of the frame line
            colored_logo=$(colorize_string "${current_frame_array[$i]}")
            
            # Add line clearing and content
            frame_output+="\r\033[K"
            
            # Build the line with system info if needed
            if [ $i -ge $start_line ] && [ $((i - start_line)) -lt ${#sys_info[@]} ]; then
                visual_length=$(get_visual_length "${current_frame_array[$i]}")
                padding_spaces=$((total_logo_width - visual_length))
                padding=$(printf "%${padding_spaces}s" "")
                frame_output+="${left_padding}${colored_logo}${padding}${sys_info[$((i - start_line))]}"
            else
                frame_output+="${left_padding}${colored_logo}"
            fi
            
            # Add newline except for last line
            if [ $i -lt $((${#current_frame_array[@]} - 1)) ]; then
                frame_output+="\n"
            fi
        done
        
        # Print the entire frame at once
        printf "%b" "$frame_output"
        
        # Restore cursor position
        restore_cursor_position
        
        
        # Wait 300ms for frame animation
        if [[ $current_frame -eq 2 || $current_frame -eq 3 || $current_frame -eq 4 || $current_frame -eq 5 || $current_frame -eq 6 || $current_frame -eq 7 ]]; then
          sleep 0.1
        else
          sleep "$delay"
        fi

        # Move to next frame
        current_frame=$(( (current_frame + 1) % frame_count ))
    done
}


cleanup() {
    tput cnorm # Restore cursor
    clear
    exit
}

# Trap SIGINT and SIGTERM to clean up properly
trap cleanup SIGINT SIGTERM

# Hide the cursor
tput civis

# clear 
clear

# Print top padding
print_empty_lines $TOP_PADDING


get_visual_length() {
    local string="$1"
    # Remove color codes and count actual visible characters
    # Then remove escape characters from the count
    echo -n "$string" | 
        sed 's/\x1b\[[0-9;]*m//g' | 
        sed 's/\\./x/g' | # Replace escaped chars with single char
        wc -m | 
        tr -d ' '
}

# Create left padding string
left_padding=$(printf "%${LEFT_PADDING}s" "")

# Calculate the maximum length across ALL frames for consistent alignment
max_logo_length=0
for frame_name in "${frames[@]}"; do
    eval "current_frame=(\"\${${frame_name}[@]}\")"
    for line in "${current_frame[@]}"; do
        current_length=$(get_visual_length "$line")
        if ((current_length > max_logo_length)); then
            max_logo_length=$current_length
        fi
    done
done

# Add padding between logo and info
padding=20

# Starting line for system information (0-based index)
start_line=5

total_logo_width=$((max_logo_length + padding))

# Print first frame and information side by side
# Create a temporary array to reference the first frame
eval "initial_frame=(\"\${frame_0[@]}\")"
for i in "${!initial_frame[@]}"; do
    colored_logo=$(colorize_string "${initial_frame[$i]}")
    
    if [ $i -ge $start_line ] && [ $((i - start_line)) -lt ${#sys_info[@]} ]; then
        visual_length=$(get_visual_length "${initial_frame[$i]}")
        padding_spaces=$((total_logo_width - visual_length))
        padding=$(printf "%${padding_spaces}s" "")
        echo -e "${left_padding}${colored_logo}${padding}${sys_info[$((i - start_line))]}"
    else
        echo -e "${left_padding}${colored_logo}"
    fi
done

# Print bottom padding
print_empty_lines $BOTTOM_PADDING

# Move cursor up to the start of the logo
move_cursor_up $((${#frame_0[@]} + BOTTOM_PADDING))

# Start the color update loop
update_colors
